source("helperFunctionsNewSCV.R")#These functions combined all simulate locally weighted regression with differing amounts of spatial variation in the data, which are provided by the user.  This script documents each function and provides examples along the way.  #First I describe the largest function, which runs all of the tests, then I document the smaller functions called within it.  #Before running the functions, the user must decide what parameters for the data generation process to test.  The values to set are the sample size, standard deviation of the error term, and the number of repetitions of each parameter set along with the spatial variation in B0 (the intercept), B1, and B2 (which are coefficients on the independent variables)# B1 and B2 are functions of east and north respectively, with the spatial variation determining how much a one unit shift in the location increases the coefficient.  The spatial variation of B0 lacks an intuitive interpretation, but it does control how quickly the intercept changes over the region.  The equations for both are shown later in this document.  # To set the parameters, store all the levels you want to test in vectors like so:sampleSizes <- c(60) B0.SpVar <- c(0, 2)B1.SpVar <- c(0)B2.SpVar <- c(4)errors <- c(1)numRepeats <- 1# Then arrange them all in a grid to create all possible combinationstestParams <- expand.grid(numRepeats = numRepeats, B0SpatialVar = B0.SpVar, B1SpatialVar = B1.SpVar, B2SpatialVar = B2.SpVar, errorSD = errors, sampleSizes = sampleSizes)testParams# The above grid should show all the different sets of parameters you would like to run.  # Now this function below runs locally weighted regression for each row in testParams (and repeats that row numRepeats times).  If MC = T, then the function runs each repetition on a new core (all repetitions must finish before the function moves to the next parameter set though).  # This should take about 4 minutes to complete.  finalResults <- mcMultParams(testParams, MC = T)finalResults# finalResults is now an array of sets of 14x22 matrices.  There is one matrix for every repetition of every parameter set run.  In the matrix, the row label is what metric was minimized to select the bandwidth and model (the model being which variables were local and which were global).# The first two columns are the selected model number and bandwidth, and the remaining columns are the values for the different metrics we calculated.  # You should also notice two new save files in your working directory, mcOutput.rds and mcOutputFinal.rds.  mcOutput.rds is created and updated after each row in testParams finishes, so that the results can be analyzed before everything is finished.  mcOutputFinal.rds is the final output and should be identical to mcOutput.rds once the code finishes.#### Internal functions# These functions are called within mcMultParams# uberFunction runs a single set of parameters (i.e. one row from testParams), generates a data set, and outputs one of the individual 14x22 matrices in results.  uberResult <- uberFunction(repetition =5, sampleSize =60, errorSD = 1, B0.SpVar = 2, B1.SpVar = 0, B2.SpVar = 2)uberResult# megaMaker is used in uberFunction to take as inputs a set of bandwidths to use, a set of model numbers to test, and a dataframe and to output a list containing the yhat estimates, coefficient estimates, leverages, and yhat estimates without the each observation (for the SCV and LOOCV metrics).  # Usually this is only called within a larger function, so to provide an example the code below generates the dataset and needed parameters for the first row in testParams above.  # Loading the parameters from testParams:n <- testParams[1,"sampleSizes"]errorSD <- testParams[1,"errorSD"]B0.SpVar <- testParams[1, "B0SpatialVar"]B1.SpVar <- testParams[1, "B1SpatialVar"]B2.SpVar <- testParams[1, "B2SpatialVar"]# The following generates the data setn = sampleSize # number of observations in our simulationeast = runif(n) # create a location variablenorth = runif(n) # create another location variablex0 = rep(1, n) # create a vector of 1's to serve as the intercept columnx1 = runif(n) # create a vector for x1 valuesx2 = runif(n) # create a vector for x2 valueserror = rnorm(n, 0, errorSD) # create an error term# Now generating the betas...# They will always have an expectation of 2 and have an expected correlation of 0.  B1 <- 2 - .5*B1.SpVar + east*B1.SpVarB2 <- 2 - .5*B2.SpVar + north*B2.SpVarB0 <- 2 + B0.SpVar*(.387452 + cos(2*pi*sqrt((east - .5)^2 + (north- .5)^2)/sqrt(.5)))# And the y valuesy = B0*x0 + B1*x1 + B2*x2 + error # generate the dependent variable values according to our mydata = data.frame(y, x0, x1, x2, east, north) # put everything together into a data frame# Now generating the bandwidthsnumk = 7 # number of bandwidths we'll usekrat = 2/3 # rate at which bandwidths decrease (ie. 45 -> 30 -> 20, etc.)ks = n-1 # this is the largest value of kfor (i in 2:numk) ks = c(round(krat*min(ks), 0), ks) # this generates the vector of bandwidths#now generating the modelsX0 = X1 = X2 = c("TRUE", "FALSE") #true is stationarymodels = as.matrix(expand.grid(x0 = X0, x1 = X1, x2 = X2))# Finally, an example of megaMaker is run here:megaResults <- megaMaker(ks, models = models[1:8,], data = mydata)megaResults # As you can see, this function's output is not easily analyzed, which is why the uberFunction reorganizes it into a matrix.  # Finally, the function mixedGWR actually runs mixed globally weighted regression.  It takes a single bandwidth, an assumed model, and a dataframe as inputs.  # The example below runs a bandwidth of 5, assumes the intercept and B1 are stationary (with B2 being non-stationary), and uses the data set generated previously.mixedResults <- mixedLWR(bandwidth = ks[1], stationary = c("TRUE", "TRUE", "FALSE"), data = mydata)mixedResults# The output is one of the individual entries in the megaResults above.  #Some other functions are used (and included in the sourced file), but they are mostly trivial.  They perform minor operations to make the outputs more readable.  These four functions are the main ones.    